.version 7.0
.target sm_70
.address_size 64


// ReLU:  c[i] = max(0, a[i])
.visible .entry relu(
    .param .u64 d_a,
	.param .u64 d_c,
	.param .u32 n
)
{
    .reg .pred 	p1, p2;
	.reg .f32 	val_a, val_c, zero;
	.reg .u64 	rd_a, rd_c;
	.reg .u64 	addr_a, addr_c;
	.reg .u64 	offset, ptr_a, ptr_c;
    .reg .u32 	ctaid, ntid, tid, idx;
    .reg .u32 	total_size;

    ld.param.u64 	rd_a, [d_a];
	ld.param.u64 	rd_c, [d_c];
	ld.param.u32 	total_size, [n];
    mov.u32 	ctaid, %ctaid.x;
	mov.u32 	ntid, %ntid.x;
	mov.u32 	tid, %tid.x;
	mad.lo.u32 	idx, ctaid, ntid, tid;
    setp.ge.u32 	p1, idx, total_size;
	@p1 bra 	$PASS_RELU;

	cvta.to.global.u64 	addr_a, rd_a;
	mul.wide.u32 	offset, idx, 4;
	add.u64 	ptr_a, addr_a, offset;
	ld.global.f32 	val_a, [ptr_a];
    mov.f32     zero, 0.0;
    max.f32 	val_c, val_a, zero;
	cvta.to.global.u64 	addr_c, rd_c;
	add.u64 	ptr_c, addr_c, offset;
	st.global.f32 	[ptr_c], val_c;

$PASS_RELU:
	ret;
}

// Sigmoid: c[i] = 1 / (1 + exp(-a[i])) with input clamping
.visible .entry sigmoid(
    .param .u64 d_a,
	.param .u64 d_c,
	.param .u32 n
)
{
    .reg .pred 	p1;
	.reg .f32 	val_a, val_c, neg_val, exp_val, one, log2e, denom;
	.reg .f32 	clamped_val, min_val, max_val;
	.reg .u64 	rd_a, rd_c;
	.reg .u64 	addr_a, addr_c;
	.reg .u64 	offset, ptr_a, ptr_c;
    .reg .u32 	ctaid, ntid, tid, idx;
    .reg .u32 	total_size;

    ld.param.u64 	rd_a, [d_a];
	ld.param.u64 	rd_c, [d_c];
	ld.param.u32 	total_size, [n];
    mov.u32 	ctaid, %ctaid.x;
	mov.u32 	ntid, %ntid.x;
	mov.u32 	tid, %tid.x;
	mad.lo.u32 	idx, ctaid, ntid, tid;
    setp.ge.u32 	p1, idx, total_size;
	@p1 bra 	$PASS_SIGMOID;

	cvta.to.global.u64 	addr_a, rd_a;
	mul.wide.u32 	offset, idx, 4;
	add.u64 	ptr_a, addr_a, offset;
	ld.global.f32 	val_a, [ptr_a];
    
    // Clamp input to [-88, 88] to prevent overflow/underflow
    mov.f32     min_val, 0fC2B00000;  
    mov.f32     max_val, 0f42B00000;   
    max.f32     clamped_val, val_a, min_val;
    min.f32     clamped_val, clamped_val, max_val;
    
 
    neg.f32     neg_val, clamped_val;
    mov.f32     log2e, 0F3FB8AA3B;  
    mul.f32     neg_val, neg_val, log2e;
    ex2.approx.f32  exp_val, neg_val;
    mov.f32     one, 1.0;
    add.f32     denom, exp_val, one;
    rcp.approx.f32  val_c, denom;
    
    // Clamp output to [0, 1] for safety
    mov.f32     min_val, 0.0;
    mov.f32     max_val, 1.0;
    max.f32     val_c, val_c, min_val;
    min.f32     val_c, val_c, max_val;
    
	cvta.to.global.u64 	addr_c, rd_c;
	add.u64 	ptr_c, addr_c, offset;
	st.global.f32 	[ptr_c], val_c;

$PASS_SIGMOID:
	ret;
}

// Tanh: c[i] = tanh(a[i])
// Uses two-path approach: polynomial for small |x|, exp-based for large |x|
.visible .entry tanh(
    .param .u64 d_a,
	.param .u64 d_c,
	.param .u32 n
)
{
    .reg .pred 	p1, p2, p3;
	.reg .f32 	f1, f2, f3, f4, f5, f6, f7, f8, f9, f10;
	.reg .f32 	f11, f12, f13, f14, f15, f16, f17, f18, f19, f20;
	.reg .f32 	f21, f22, f23;
	.reg .u64 	rd1, rd2, rd3, rd4, rd5, rd6, rd7;
    .reg .u32 	ctaid, ntid, tid, idx;
    .reg .u32 	total_size;

    ld.param.u64 	rd1, [d_a];
	ld.param.u64 	rd2, [d_c];
	ld.param.u32 	total_size, [n];
    mov.u32 	ctaid, %ctaid.x;
	mov.u32 	ntid, %ntid.x;
	mov.u32 	tid, %tid.x;
	mad.lo.u32 	idx, ctaid, ntid, tid;
    setp.ge.u32 	p1, idx, total_size;
	@p1 bra 	$PASS_TANH;

	cvta.to.global.u64 	rd3, rd1;
	mul.wide.u32 	rd4, idx, 4;
	add.u64 	rd5, rd3, rd4;
	ld.global.f32 	f1, [rd5];
    
    abs.f32 	f2, f1;
    
    // Large |x| path: exp-based approximation
    mul.f32 	f3, f2, 0f4038AA3B;
    ex2.approx.ftz.f32 	f4, f3;
    add.f32 	f5, f4, 0f3F800000;
    mov.f32 	f6, 0f3F800000;
    rcp.approx.ftz.f32 	f7, f5;
    mov.f32 	f8, 0fC0000000;
    fma.rn.f32 	f9, f7, f8, f6;
    setp.ge.f32 	p2, f2, 0f41102CB4;  // threshold ~9.01
    selp.f32 	f10, 0f3F800000, f9, p2;
    copysign.f32 	f11, f1, f10;
    
    // Small |x| path: polynomial approximation
    mul.f32 	f12, f1, f1;
    mov.f32 	f13, 0fBD563CAE;
    mov.f32 	f14, 0f3C80F082;
    fma.rn.f32 	f15, f14, f12, f13;
    mov.f32 	f16, 0f3E085941;
    fma.rn.f32 	f17, f15, f12, f16;
    mov.f32 	f18, 0fBEAAA9ED;
    fma.rn.f32 	f19, f17, f12, f18;
    mov.f32 	f20, 0f00000000;
    fma.rn.f32 	f21, f19, f12, f20;
    fma.rn.f32 	f22, f21, f1, f1;
    
    // Select between the two paths
    setp.ge.f32 	p3, f2, 0f3F19999A;  // threshold ~0.6
    selp.f32 	f23, f11, f22, p3;
    
    cvta.to.global.u64 	rd6, rd2;
	add.u64 	rd7, rd6, rd4;
	st.global.f32 	[rd7], f23;

$PASS_TANH:
	ret;
}